# System Document v1 — ISO/IEC 20000 Change Compliance Agent (Observe → Warn → Gate)

This version incorporates the explicit **RiskLevel enum** (LOW/MEDIUM/HIGH/CRITICAL/UNKNOWN) and preserves the design decisions from our conversation: PR-merge as the canonical control point, Jira as the workflow record, agent as compliance evidence ledger, and no LLM-only enforcement.

---

## 1. Objective

Build a self-developed agent that evaluates and logs change-management compliance aligned to ISO/IEC 20000-1, with a phased rollout:

* **Phase 1 (Observe):** Evidence collection + compliance evaluation + immutable logging; optional Jira comments; no blocking.
* **Phase 2 (Warn):** Soft gates (notify on non-compliance at key Jira transitions); no blocking.
* **Phase 3 (Gate):** Minimal hard gates (block transitions) based on objective evidence; risk selects required controls.

---

## 2. Governing principles

### P1 — Single control plane

* **Jira** owns workflow state (status transitions).
* **GitHub** is the system-of-record for implementation evidence (PR merge, reviews, checks).
* **Agent datastore** is the system-of-record for compliance evidence (snapshots + evaluations).

### P2 — Canonical identification point

A change candidate is created when a **PR is merged** into a **production-bound branch** (protected branch pattern list).

### P3 — Risk is a selector, not a gate

Risk does **not** decide “allow/deny.” Risk decides which controls are required and must be evidenced.

### P4 — Change type is evidence-driven

* **Emergency** requires explicit evidence (incident/security link or explicit declared emergency path).
* **Standard** requires explicit model reference (optional; can be deferred).
* Otherwise default to **Normal**.

### P5 — LLM is advisory only

LLM output may be used for summaries/rationales. Deterministic rules determine compliance and any gating decisions.

---

## 3. ISO/IEC 20000-1:2018 clause mapping (applied controls)

The following ISO/IEC 20000-1:2018 requirements map to the implemented controls:

* **7.5.4** documented information shall include change management policy
* **8.5.1.1(b)** Change policy defines categories, including emergency change.
* **8.5.1.1(c)** Policy defines criteria to determine changes with major impact.
* **8.5.1.2** Requests for change shall be recorded and classified.
* **8.5.1.3** Decisions on approval and priority for requests for change.
* **6.1.2** Determine and document risks/impacts and risk acceptance criteria (SMS planning).
* **8.5.2.3** Service components are built and tested to meet acceptance criteria.
* **8.5.3** Define types of release, including emergency release (as applicable).

Implementation note: ISO does not mandate Jira custom fields. “Recorded and classified” and “risk/impact considered and recorded” are satisfied by a combination of Jira issue + agent ledger + optional Jira comment.

---

## 4. Minimal required conventions and configuration

### 4.1 PR-to-Jira correlation key (required)

PR title or body must contain the Jira key (e.g., `ABC-123`). This enables deterministic mapping.

### 4.2 Production-bound branch patterns (required)

Configuration value `PROD_BOUND_BRANCH_PATTERNS`, e.g.:

* `main`
* `release/*`
* `hotfix/*`

### 4.3 Objective evidence sources (recommended)

GitHub branch protection should define:

* required status checks
* required reviews (including CODEOWNERS if applicable)

This makes controls objective and machine-verifiable.

---

## 5. Classification model

### 5.1 ChangeType (enum)

`ChangeType` is the governance route.

* `STANDARD`
* `NORMAL`
* `EMERGENCY`
* `INCONCLUSIVE` (insufficient evidence to classify)

**Derivation rules (Phase 1):**

* `EMERGENCY` only if explicit evidence exists:

  * linked major incident/security incident, or
  * explicit emergency declaration marker (future) with required evidence.
* `STANDARD` only if explicit standard change model reference exists (optional; may be deferred).
* Otherwise `NORMAL`.
* If correlation is missing (no Jira key) and no explicit emergency/model evidence, `INCONCLUSIVE`.

### 5.2 RiskLevel (enum)

`RiskLevel` is used to select control strength.

* `LOW`
* `MEDIUM`
* `HIGH`
* `CRITICAL`
* `UNKNOWN` (insufficient context/evidence)

**Important:** Risk is recorded to demonstrate proportionality of controls, consistent with ISO planning and change control expectations.

---

## 6. Data model and records (authoritative agent ledger)

### 6.1 Snapshot definition

A **Snapshot** is an immutable capture of evidence at a point in time (GitHub/Jira state) to prevent later edits from rewriting history.

### 6.2 Entities

#### A) ChangeCandidate

Created per merged PR to production-bound branch.

* `candidate_id` (UUID)
* `repo`, `pr_number`, `pr_url`
* `base_branch`, `merge_sha`, `merged_at`
* `jira_keys[]` (0..n)

#### B) EvidenceSnapshot (append-only)

* `snapshot_id` (UUID)
* `candidate_id`
* `captured_at`
* `agent_version`
* `payload_hashes` (per payload)
* Payloads (raw or normalized):

  * `github_pr`
  * `github_reviews`
  * `github_checks`
  * `jira_issue` (nullable)
  * `deployment` (optional)
  * `incident` (optional)

#### C) ComplianceEvaluation (append-only)

* `evaluation_id` (UUID)
* `snapshot_id`
* `policy_id`, `policy_version`
* `evaluated_at`
* `overall_status`: `COMPLIANT | NON_COMPLIANT | INCONCLUSIVE`
* `controls[]`: `{control_id, status, reason_codes[], evidence_refs[]}`
* `missing_items[]` (human-readable)
* `change_type`: `ChangeType`
* `change_type_basis[]` (evidence pointers)

**Risk structure (with enums + provenance):**

* `risk_declared` (nullable)

  * `level`: `RiskLevel`
  * `source`: `HUMAN`
  * `actor` (if available)
  * `timestamp`
* `risk_recommended` (nullable)

  * `level`: `RiskLevel`
  * `source`: `AGENT_RULES`
  * `confidence`: `HIGH | MEDIUM | LOW`
  * `signals[]` (machine-readable triggers)
  * `evaluated_at`
* `risk_effective`

  * `level`: `RiskLevel`
  * `source`: `HUMAN | AGENT_RULES | NONE`
  * rule: declared wins; else recommended; else `UNKNOWN`

---

## 7. Controls (policy v1) and evidence requirements

These implement “recorded and classified,” “approval decisions,” and “built/tested acceptance evidence” expectations.

### Control set (objective, deterministic)

#### CHG-C1 Traceability (Record and classify)

* PASS: PR contains Jira key and Jira issue exists.
* FAIL: Jira key missing OR Jira issue not found.
* UNKNOWN: Jira API unavailable.

#### CHG-C2 Merge integrity

* PASS: PR merged AND base branch matches production-bound patterns.
* FAIL: not merged or not production-bound.

#### CHG-C3 Required checks (Testing evidence)

* PASS: all required checks successful at evaluation snapshot.
* FAIL: any required check missing/failing.
* UNKNOWN: check data unavailable.

#### CHG-C4 Required reviews (Approval evidence)

* PASS: approvals meet configured rule (count/roles/CODEOWNERS).
* FAIL: missing required approvals.
* UNKNOWN: review data unavailable.

Optional controls for v2+:

* rollback/verification note link present for HIGH/CRITICAL
* deployment evidence present for CRITICAL or for closure
* emergency incident link + PIR completion

---

## 8. Risk rubric (rules-first mapping to RiskLevel enum)

### 8.1 Deterministic signals taxonomy (examples)

* `SCHEMA_CHANGE`
* `AUTHZ_CHANGE`
* `PAYMENTS_DOMAIN`
* `INFRA_IAC_CHANGE`
* `TIER0_SERVICE`
* `MULTI_SERVICE_TOUCH`
* `SECURITY_REMEDIATION_EXPLICIT`
* `INSUFFICIENT_CONTEXT`

### 8.2 Mapping (initial baseline; tune over time)

**CRITICAL** if any of:

* `TIER0_SERVICE` AND (`SCHEMA_CHANGE` OR `AUTHZ_CHANGE` OR `PAYMENTS_DOMAIN`)
* `SECURITY_REMEDIATION_EXPLICIT` for active exploitation (explicit input)

**HIGH** if any of:

* `SCHEMA_CHANGE`
* `AUTHZ_CHANGE`
* `PAYMENTS_DOMAIN`
* `INFRA_IAC_CHANGE`
* `MULTI_SERVICE_TOUCH` above threshold

**MEDIUM** if any of:

* production-bound change with moderate blast radius and no high triggers
* missing service tier but other signals suggest non-trivial impact

**LOW**

* none of the above triggers; narrow scope; strongly reversible; routine domains

**UNKNOWN**

* insufficient data to compute (API failures, correlation failure, missing key context)

### 8.3 Confidence computation

* HIGH confidence: signals derived from objective sources (files/path rules, repo classification, explicit metadata).
* MEDIUM: some objective signals + missing context (service tier unknown).
* LOW: major evidence missing or correlation incomplete.

LLM may summarize, but does not alter the rule outcomes.

---

## 9. Phase 1 execution steps (Observe)

### Trigger

GitHub webhook: PR merged.

### Steps

1. **Ingest**

   * Validate: merged = true; base branch in scope.

2. **Correlate**

   * Extract Jira key(s). If none → proceed but mark traceability likely FAIL and evaluation likely INCONCLUSIVE.

3. **Collect GitHub snapshot**

   * PR metadata, merge SHA, timestamps
   * approvals/reviews
   * checks + required check results
   * changed files list (metadata)

4. **Collect Jira snapshot (if key exists)**

   * issue metadata, status, issue type
   * any declared risk/type fields if implemented
   * incident/deployment links if present

5. **Derive ChangeType**

   * Apply explicit evidence rules (Emergency/Standard/Normal).

6. **Compute risk**

   * Use declared risk if present; else compute recommendation (RiskLevel enum + signals + confidence).

7. **Evaluate controls**

   * CHG-C1..C4 with deterministic results.

8. **Persist**

   * Write EvidenceSnapshot (append-only)
   * Write ComplianceEvaluation (append-only)

9. **Optional Jira write-back**

   * Post standardized comment (Section 12).

No blocking.

---

## 10. Phase 2 execution steps (Warn)

### Trigger

Jira transition into key states (e.g., `Ready to Implement`, `Done`) or periodic scan.

### Steps

* Fetch latest evaluation for Jira key.
* If `NON_COMPLIANT` or `INCONCLUSIVE`, comment with missing items.
* Optionally apply marker label `compliance-fail` (not authoritative).

No blocking.

---

## 11. Phase 3 execution steps (Gate)

### Gate placement (recommended)

* Gate transition into `Approved/Ready to Implement`.
* Optional gate into `Done` (if you require deployment evidence or PIR).

### Gate logic

* Must have latest evaluation = `COMPLIANT` for current policy version.
* Risk selects additional objective requirements:

  * if `risk_effective.level in {HIGH, CRITICAL}` → require rollback plan evidence, higher approver role, etc.
* No gate depends on LLM-generated statements.

---

## 12. Standardized Jira comment template (recommended)

**Header**

* `Compliance evaluation (chg-policy@1.0.0): COMPLIANT|NON_COMPLIANT|INCONCLUSIVE`

**Evidence**

* PR: `<url>`
* Merge SHA: `<sha>`
* Base branch: `<branch>`
* Evaluated at: `<timestamp>`

**Classification**

* `Change type (derived): STANDARD|NORMAL|EMERGENCY|INCONCLUSIVE`
* `Basis: <incident link/model ref/default>`

**Risk**

* `Risk (declared): <RiskLevel> (if present)`
* `Risk (recommended): <RiskLevel> (confidence: H/M/L)`
* Signals:

  * `- SCHEMA_CHANGE`
  * `- INFRA_IAC_CHANGE`

**Controls**

* CHG-C1 Traceability: PASS/FAIL/UNKNOWN
* CHG-C2 Merge integrity: PASS/FAIL/UNKNOWN
* CHG-C3 Required checks: PASS/FAIL/UNKNOWN (list failures)
* CHG-C4 Required reviews: PASS/FAIL/UNKNOWN (list missing)

**Missing items / actions (if applicable)**

* `- Add Jira key to PR title`
* `- Fix failing check: unit-tests`
* `- Obtain required approval (CODEOWNERS)`

---

## 13. Minimum responsibilities by party

### Developer

* Ensure Jira key in PR title/body.
* Follow PR-based workflow (avoid direct pushes to protected branches).

### GitHub configuration owner

* Define required checks and review rules.

### Agent

* Collect evidence snapshots; evaluate; log immutably; comment to Jira (optional).

### Jira/project owner

* Provide stable workflow statuses and permissions for the agent to comment (Phase 1–2).
* Add gates only in Phase 3.

---

## 14. Implementation checklist (Phase 1)

* GitHub webhook receiver for merged PR
* GitHub API client for:

  * PR details, reviews, checks
* Jira API client for:

  * issue read, comment write (optional but recommended)
* Append-only evidence store
* Policy evaluator (CHG-C1..C4)
* Risk rules engine outputting `RiskLevel` enum + signals + confidence
* Optional LLM summarizer (non-authoritative)

---

If you want, I can add a “Policy Annex v1” with:

* the complete signals dictionary and detection rules (file/path patterns, repo/service tier mapping),
* the exact review and checks requirements as configurable policy objects,
* and standardized reason codes for each FAIL/UNKNOWN outcome so your logs are queryable and consistent.
